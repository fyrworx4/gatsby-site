"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var blocks_1 = require("../blocks");
var inlines_1 = require("../inlines");
var validation_1 = require("../validation");
var document = function (args) {
    var content = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        content[_i - 1] = arguments[_i];
    }
    return (__assign({ nodeType: blocks_1.BLOCKS.DOCUMENT, data: {}, content: content }, args));
};
var node = function (nodeType, args) {
    var content = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        content[_i - 2] = arguments[_i];
    }
    return (__assign({ nodeType: nodeType, data: {}, content: content }, args));
};
var text = function (value, args) {
    if (value === void 0) { value = ''; }
    return (__assign({ nodeType: 'text', data: {}, marks: [], value: value }, args));
};
var topLevelBlocks = [
    blocks_1.BLOCKS.EMBEDDED_ASSET,
    blocks_1.BLOCKS.EMBEDDED_ENTRY,
    blocks_1.BLOCKS.HEADING_1,
    blocks_1.BLOCKS.HEADING_2,
    blocks_1.BLOCKS.HEADING_3,
    blocks_1.BLOCKS.HEADING_4,
    blocks_1.BLOCKS.HEADING_5,
    blocks_1.BLOCKS.HEADING_6,
    blocks_1.BLOCKS.HR,
    blocks_1.BLOCKS.OL_LIST,
    blocks_1.BLOCKS.PARAGRAPH,
    blocks_1.BLOCKS.QUOTE,
    blocks_1.BLOCKS.TABLE,
    blocks_1.BLOCKS.UL_LIST,
].sort();
var listBlocks = [
    blocks_1.BLOCKS.EMBEDDED_ASSET,
    blocks_1.BLOCKS.EMBEDDED_ENTRY,
    blocks_1.BLOCKS.HEADING_1,
    blocks_1.BLOCKS.HEADING_2,
    blocks_1.BLOCKS.HEADING_3,
    blocks_1.BLOCKS.HEADING_4,
    blocks_1.BLOCKS.HEADING_5,
    blocks_1.BLOCKS.HEADING_6,
    blocks_1.BLOCKS.HR,
    blocks_1.BLOCKS.OL_LIST,
    blocks_1.BLOCKS.PARAGRAPH,
    blocks_1.BLOCKS.QUOTE,
    blocks_1.BLOCKS.UL_LIST,
].sort();
describe('validateRichTextDocument', function () {
    describe('root node', function () {
        it('fails if it is not document node', function () {
            var value = node(blocks_1.BLOCKS.PARAGRAPH);
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/nodeType',
                    message: 'must be equal to one of the allowed values',
                    params: {
                        allowedValues: ['document'],
                    },
                    data: blocks_1.BLOCKS.PARAGRAPH,
                }),
            ]);
        });
        it('does not allow invalid root document shape', function () {
            var value = { nodeType: blocks_1.BLOCKS.DOCUMENT };
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'required',
                    instancePath: '',
                    message: "must have required property 'content'",
                }),
                expect.objectContaining({
                    keyword: 'required',
                    instancePath: '',
                    message: "must have required property 'data'",
                }),
            ]);
        });
        it('does not allow nested documents', function () {
            var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH), node(blocks_1.BLOCKS.UL_LIST, {}, node(blocks_1.BLOCKS.LIST_ITEM, {}, node(blocks_1.BLOCKS.DOCUMENT))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    message: 'must be equal to one of the allowed values',
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    params: {
                        allowedValues: listBlocks,
                    },
                    data: 'document',
                }),
            ]);
        });
        it('does not allow custom nodeTypes', function () {
            var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, node('custom-type', {}, node(blocks_1.BLOCKS.PARAGRAPH))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: 'must be equal to one of the allowed values',
                    params: {
                        allowedValues: Object.values(inlines_1.INLINES).sort(),
                    },
                    data: 'custom-type',
                }),
            ]));
        });
    });
    describe('direct children of root node', function () {
        it('validate with blocks as direct children of the root node', function () {
            var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([]);
        });
        it("fails with " + blocks_1.BLOCKS.LIST_ITEM + " as immediate child of root node", function () {
            var value = document({}, node(blocks_1.BLOCKS.LIST_ITEM, {}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(''))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    message: 'must be equal to one of the allowed values',
                    instancePath: '/content/0/nodeType',
                    params: {
                        allowedValues: topLevelBlocks,
                    },
                    data: blocks_1.BLOCKS.LIST_ITEM,
                }),
            ]);
        });
        var _loop_1 = function (dependentNode) {
            it("fails with " + dependentNode + " as immediate child of root node", function () {
                var value = document({}, node(dependentNode, {}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(''))));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'enum',
                        message: 'must be equal to one of the allowed values',
                        instancePath: '/content/0/nodeType',
                        params: {
                            allowedValues: topLevelBlocks,
                        },
                        data: dependentNode,
                    }),
                ]);
            });
        };
        for (var _i = 0, _a = [blocks_1.BLOCKS.TABLE_ROW, blocks_1.BLOCKS.TABLE_CELL, blocks_1.BLOCKS.TABLE_HEADER_CELL]; _i < _a.length; _i++) {
            var dependentNode = _a[_i];
            _loop_1(dependentNode);
        }
        it('fail with inlines as direct children', function () {
            var value = document({}, node(inlines_1.INLINES.HYPERLINK, { data: { uri: '' } }));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: 'must be equal to one of the allowed values',
                    params: {
                        allowedValues: topLevelBlocks,
                    },
                    data: inlines_1.INLINES.HYPERLINK,
                }),
            ]);
        });
        it('fail with text as direct children', function () {
            var value = document({}, text());
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: topLevelBlocks,
                    },
                    data: 'text',
                }),
            ]));
        });
        it('fail with text and inline as direct children', function () {
            var value = document({}, text(), node(blocks_1.BLOCKS.PARAGRAPH), node(inlines_1.INLINES.ASSET_HYPERLINK, { data: { target: {} } }));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: topLevelBlocks,
                    },
                    data: 'text',
                }),
            ]));
        });
    });
    describe('children constraints', function () {
        var _loop_2 = function (listNode) {
            it("allows only " + blocks_1.BLOCKS.LIST_ITEM + " as immediate children of list nodes (" + listNode + ")", function () {
                var value = document({}, node(listNode, {}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(''))));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'enum',
                        instancePath: '/content/0/nodeType',
                        message: "must be equal to one of the allowed values",
                        params: {
                            allowedValues: [blocks_1.BLOCKS.LIST_ITEM],
                        },
                        data: blocks_1.BLOCKS.PARAGRAPH,
                    }),
                ]);
            });
        };
        for (var _i = 0, _a = [blocks_1.BLOCKS.UL_LIST, blocks_1.BLOCKS.OL_LIST]; _i < _a.length; _i++) {
            var listNode = _a[_i];
            _loop_2(listNode);
        }
        it("allows only " + blocks_1.BLOCKS.TABLE_ROW + " as immediate children of table nodes", function () {
            var value = document({}, node(blocks_1.BLOCKS.TABLE, {}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(''))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: [blocks_1.BLOCKS.TABLE_ROW],
                    },
                    data: blocks_1.BLOCKS.PARAGRAPH,
                }),
            ]);
        });
        it("allows only table cell nodes as immediate children of a " + blocks_1.BLOCKS.TABLE_ROW + " nodes", function () {
            var value = document({}, node(blocks_1.BLOCKS.TABLE, {}, node(blocks_1.BLOCKS.TABLE_ROW, {}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text('')))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: [blocks_1.BLOCKS.TABLE_CELL, blocks_1.BLOCKS.TABLE_HEADER_CELL],
                    },
                    data: blocks_1.BLOCKS.PARAGRAPH,
                }),
            ]);
        });
        it("allows only block nodes as direct children of " + blocks_1.BLOCKS.LIST_ITEM + " nodes", function () {
            var value = document({}, node(blocks_1.BLOCKS.UL_LIST, {}, node(blocks_1.BLOCKS.LIST_ITEM, {}, text(''))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: listBlocks,
                    },
                    data: 'text',
                }),
            ]));
        });
        it("allows only paragraphs as direct children of " + blocks_1.BLOCKS.TABLE_CELL + " nodes", function () {
            var value = document({}, node(blocks_1.BLOCKS.TABLE, {}, node(blocks_1.BLOCKS.TABLE_ROW, {}, node(blocks_1.BLOCKS.TABLE_CELL, {}, text('')))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: ['paragraph'],
                    },
                    data: 'text',
                }),
            ]));
        });
        it('allows inlines to contain only inline or text nodes', function () {
            var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, node(inlines_1.INLINES.HYPERLINK, { data: { uri: '' } }, node(blocks_1.BLOCKS.PARAGRAPH, {}, text('')))));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual(expect.arrayContaining([
                expect.objectContaining({
                    keyword: 'enum',
                    instancePath: '/content/0/nodeType',
                    message: "must be equal to one of the allowed values",
                    params: {
                        allowedValues: ['text'],
                    },
                    data: blocks_1.BLOCKS.PARAGRAPH,
                }),
            ]));
        });
        it("allows only " + blocks_1.BLOCKS.PARAGRAPH + " as children of " + blocks_1.BLOCKS.QUOTE, function () {
            var value = document({}, node(blocks_1.BLOCKS.QUOTE, {}, node(inlines_1.INLINES.HYPERLINK, { data: { uri: '' } })));
            var errorsResult = (0, validation_1.validateRichTextDocument)(value);
            expect(errorsResult).toEqual([
                expect.objectContaining({
                    keyword: 'enum',
                    message: "must be equal to one of the allowed values",
                    instancePath: '/content/0/nodeType',
                    data: inlines_1.INLINES.HYPERLINK,
                    params: {
                        allowedValues: [blocks_1.BLOCKS.PARAGRAPH],
                    },
                }),
            ]);
        });
    });
    describe('node properties', function () {
        describe('blocks and inlines', function () {
            it('validate with required properties', function () {
                var value = {
                    nodeType: blocks_1.BLOCKS.DOCUMENT,
                    data: {},
                    content: [],
                };
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([]);
            });
            it('fail without required `nodeType` property', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, { data: {}, nodeType: null }, text('')));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        keyword: 'enum',
                        instancePath: '/content/0/nodeType',
                        message: 'must be equal to one of the allowed values',
                        params: {
                            allowedValues: topLevelBlocks,
                        },
                        data: null,
                    }),
                ]));
            });
            it('fail without required `content` property', function () {
                var value = document({}, node(blocks_1.BLOCKS.OL_LIST, {}, node(blocks_1.BLOCKS.LIST_ITEM, {}, { nodeType: blocks_1.BLOCKS.PARAGRAPH, data: {} })));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        instancePath: '',
                        message: "must have required property 'content'",
                    }),
                ]);
            });
            it('fail with invalid `content` property', function () {
                // We already test `undefined` value above (that would throw a "required" error)
                // that's why it's not included in the list.
                ['hello', 123, true, null].forEach(function (content) {
                    var value = {
                        nodeType: 'document',
                        data: {},
                        content: content,
                    };
                    var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                    expect(errorsResult).toEqual([
                        expect.objectContaining({
                            keyword: 'type',
                            instancePath: '/content',
                            message: 'must be array',
                            schema: 'array',
                            data: content,
                        }),
                    ]);
                });
            });
            it('fail with unknown/custom properties', function () {
                var value = document({
                    data: {},
                    content: [],
                    customProp: 1,
                });
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'additionalProperties',
                        instancePath: '',
                        params: {
                            additionalProperty: 'customProp',
                        },
                        message: 'must NOT have additional properties',
                    }),
                ]);
            });
            it('fail with missing & unknown/custom properties', function () {
                var value = document({
                    data: {},
                    customProp: 1,
                    content: null,
                });
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'additionalProperties',
                        instancePath: '',
                        params: {
                            additionalProperty: 'customProp',
                        },
                        message: "must NOT have additional properties",
                    }),
                    expect.objectContaining({
                        keyword: 'type',
                        instancePath: '/content',
                        message: 'must be array',
                        data: null,
                        schema: 'array',
                    }),
                ]);
            });
        });
        describe('text nodes', function () {
            it('validate with required properties', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text('')));
                var errorResults = (0, validation_1.validateRichTextDocument)(value);
                expect(errorResults).toEqual([]);
            });
            it('fail without required properties', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text('', { data: null })));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'type',
                        instancePath: '/data',
                        message: 'must be object',
                        schema: 'object',
                        data: null,
                    }),
                ]);
            });
            it('fail without required `value` property', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(null)));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'type',
                        instancePath: '/value',
                        message: 'must be string',
                        schema: 'string',
                        data: null,
                    }),
                ]);
            });
            it('fail with unknown/custom properties', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text('', { customProp: true })));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'additionalProperties',
                        instancePath: '',
                        params: {
                            additionalProperty: 'customProp',
                        },
                        message: "must NOT have additional properties",
                    }),
                ]);
            });
            it('fail with missing & unknown/custom properties', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, text(null)));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'type',
                        instancePath: '/value',
                        message: 'must be string',
                        schema: 'string',
                        data: null,
                    }),
                ]);
            });
        });
    });
    describe('properties shape', function () {
        describe('`data` property', function () {
            it('fails with missing `data` property', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, { nodeType: inlines_1.INLINES.HYPERLINK, content: [] }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        message: "must have required property 'data'",
                    }),
                ]);
            });
            it("fails with invalid properties for " + inlines_1.INLINES.HYPERLINK + " nodeTypes", function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, {
                    nodeType: inlines_1.INLINES.HYPERLINK,
                    data: {},
                    content: [text('')],
                }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        instancePath: '/data',
                        message: "must have required property 'uri'",
                    }),
                ]);
            });
            it("fails with invalid properties for " + inlines_1.INLINES.ASSET_HYPERLINK + " nodeTypes", function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, { nodeType: inlines_1.INLINES.ASSET_HYPERLINK, data: {}, content: [text()] }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        instancePath: '/data',
                        message: "must have required property 'target'",
                    }),
                ]);
            });
            it("fails with invalid properties for " + inlines_1.INLINES.ENTRY_HYPERLINK + " nodeTypes", function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, { nodeType: inlines_1.INLINES.ENTRY_HYPERLINK, data: {}, content: [text()] }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        instancePath: '/data',
                        message: "must have required property 'target'",
                    }),
                ]);
            });
            it("fails with invalid properties of " + inlines_1.INLINES.EMBEDDED_ENTRY + " nodeTypes", function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, { nodeType: inlines_1.INLINES.EMBEDDED_ENTRY, data: {}, content: [text()] }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'required',
                        instancePath: '/data',
                        message: "must have required property 'target'",
                    }),
                    expect.objectContaining({
                        keyword: 'maxItems',
                        instancePath: '/content',
                        message: 'must NOT have more than 0 items',
                        data: [
                            {
                                data: {},
                                marks: [],
                                nodeType: 'text',
                                value: '',
                            },
                        ],
                    }),
                ]);
            });
            it('fails with unknown/custom properties', function () {
                var value = document({}, node(blocks_1.BLOCKS.PARAGRAPH, {}, {
                    nodeType: inlines_1.INLINES.HYPERLINK,
                    data: { foo: true, uri: 'https://world.com' },
                    content: [text()],
                }));
                var errorsResult = (0, validation_1.validateRichTextDocument)(value);
                expect(errorsResult).toEqual([
                    expect.objectContaining({
                        keyword: 'additionalProperties',
                        instancePath: '/data',
                        params: {
                            additionalProperty: 'foo',
                        },
                        message: 'must NOT have additional properties',
                    }),
                ]);
            });
        });
    });
});
//# sourceMappingURL=validation.test.js.map