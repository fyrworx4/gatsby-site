"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRichTextDocument = void 0;
var ajv_1 = __importDefault(require("ajv"));
var blocks_1 = require("./blocks");
var helpers_1 = require("./helpers");
var schemas_1 = require("./schemas");
var ajv = new ajv_1.default({ allErrors: true, verbose: true });
/**
 * Validates a rich text document against our JSON schemas using AJV.
 *
 * We need to reduce the validation scope to keep AJV from returning error
 * messages with obscure code paths.
 *
 * Example:
 *
 * Given a node that accepts children which should match one of multiple
 * schemas, having an invalid child node (e.g., with a missing property), AJV
 * tries to validate the child node against one of the other schemas. This
 * results in misleading / cryptic error messages.
 *
 * This function runs AJV validations against nodes whose children have had
 * their properties reset, so that AJV validates only against properties of the
 * parent node's nodeType. This is the reasoning behind the `removeChildNodes`
 * and `removeGrandChildNodes` helpers.
 */
function validateRichTextDocument(document, options) {
    var _a;
    var validateRootNode = getValidator(blocks_1.BLOCKS.DOCUMENT);
    var rootNodeIsValid = validateRootNode(removeGrandChildNodes(document));
    var transformError = (_a = options === null || options === void 0 ? void 0 : options.transformError) !== null && _a !== void 0 ? _a : (function (error) { return error; });
    /**
     * Note that this is not the most beautiful / functional implementation
     * possible, but since we are validating what could potentially be a
     * substantially lengthy (hence: computationally complex) tree, we need to
     * constrain both space _and_ memory usage. This is the reasoning behind using
     * imperative logic with passed references and in-line mutation.
     */
    var errors = [];
    if (rootNodeIsValid) {
        validateChildNodes(document, ['content'], errors, transformError);
    }
    else {
        buildSchemaErrors(validateRootNode, [], errors, transformError);
    }
    return errors;
}
exports.validateRichTextDocument = validateRichTextDocument;
/**
 * Validates each child of a root node, continually (recursively) passing down
 * the path from the originating root node.
 */
function validateChildNodes(node, path, errors, transform) {
    for (var i = 0; i < node.content.length; i++) {
        validateNode(node.content[i], __spreadArray(__spreadArray([], path, true), [i], false), errors, transform);
    }
}
function validateNode(node, path, errors, transform) {
    var validateSchema = getValidator(node.nodeType);
    var isValid = validateSchema(removeGrandChildNodes(resetChildNodes(node)));
    if (!isValid) {
        buildSchemaErrors(validateSchema, path, errors, transform);
        return;
    }
    if (!isLeafNode(node)) {
        validateChildNodes(node, __spreadArray(__spreadArray([], path, true), ['content'], false), errors, transform);
    }
}
/**
 * Gets the validating function for the schema from the AJV instance. Note that
 * AJV caches the schema under the hood, while `getSchemaWithNodeType` is
 * returning JSON objects from a Webpack-ified dictionary object, so there is no
 * way to further optimize here (even though it may look otherwise).
 */
function getValidator(nodeType) {
    var schema = (0, schemas_1.getSchemaWithNodeType)(nodeType);
    return ajv.compile(schema);
}
function buildSchemaErrors(validateSchema, path, errors, transform) {
    var schemaErrors = (validateSchema.errors || []).map(function (error) { return transform(error, path); });
    errors.push.apply(errors, schemaErrors);
}
function resetChildNodes(node) {
    var content = node.content;
    if (isLeafNode(node)) {
        return node;
    }
    return Object.assign({}, node, { content: content.map(resetNode) });
}
function resetNode(node) {
    var nodeType = node.nodeType;
    if ((0, helpers_1.isText)(node)) {
        return { nodeType: nodeType, data: {}, value: '', marks: [] };
    }
    return { nodeType: nodeType, data: {}, content: [] };
}
function removeGrandChildNodes(node) {
    var content = node.content;
    if (isLeafNode(node)) {
        return node;
    }
    return Object.assign({}, node, { content: content.map(removeChildNodes) });
}
function removeChildNodes(node) {
    if ((0, helpers_1.isText)(node)) {
        return node;
    }
    return Object.assign({}, node, { content: [] });
}
function isLeafNode(node) {
    return (0, helpers_1.isText)(node) || !Array.isArray(node.content);
}
//# sourceMappingURL=validation.js.map