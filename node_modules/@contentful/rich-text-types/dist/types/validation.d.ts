import { ErrorObject } from 'ajv';
import { Node } from './types';
declare type AnyNode = Node & {
    content?: AnyNode[];
    value?: string;
    marks?: string[];
};
declare type Path = (string | number)[];
declare type ErrorTransformer<T = unknown> = (error: ErrorObject, path: Path) => T;
export declare type ValidationOptions<T> = {
    transformError?: ErrorTransformer<T>;
};
/**
 * Validates a rich text document against our JSON schemas using AJV.
 *
 * We need to reduce the validation scope to keep AJV from returning error
 * messages with obscure code paths.
 *
 * Example:
 *
 * Given a node that accepts children which should match one of multiple
 * schemas, having an invalid child node (e.g., with a missing property), AJV
 * tries to validate the child node against one of the other schemas. This
 * results in misleading / cryptic error messages.
 *
 * This function runs AJV validations against nodes whose children have had
 * their properties reset, so that AJV validates only against properties of the
 * parent node's nodeType. This is the reasoning behind the `removeChildNodes`
 * and `removeGrandChildNodes` helpers.
 */
export declare function validateRichTextDocument<T>(document: AnyNode, options?: ValidationOptions<T>): T[];
export {};
